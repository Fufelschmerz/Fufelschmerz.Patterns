# Итератор (Iterator)

Итератор — это поведенческий шаблон проектирования предназначенный для доступа к элементам коллекции(агрегата) не раскрывая её внутренней структуры.

В C# поддерживаются только однонаправленные итераторы, которые позволяют выполнять: получение текущего элемента, переход к следующему элементу и перемещение в начало коллекции(опционально).

**Правило для всех перечислителей**

> Перечислитель остаётся действительным до тех пор, пока коллекция остаётся неизменной. Если в коллекцию вносятся изменения, например добавляются, изменяются или удаляются элементы, перечислитель становится безвозвратно недействительным, и его поведение становится неопределённым.

**Классическая структура паттерна**

![Image alt](https://github.com/Fufelschmerz/Fufelschmerz.Patterns/raw/master/images/20250118143351.png)

### Реализация паттерна

Для реализации паттерна мы можем воспользоваться двумя подходами.

![Image alt](https://github.com/Fufelschmerz/Fufelschmerz.Patterns/raw/master/images/20250115203708.png)

Хотелось бы начать с менее распространённого подхода реализации итератора: **«match the pattern»**. Реализация итератора с помощью интерфейсов `IEnumerable/IEnumerable<T>` является аналогичной. Просто хочется подчеркнуть, что реализация интерфейса `IEnumerable/IEnumerable<T>` не является обязательной.

Для того чтобы реализовать итератор на основе сопоставления с шаблоном наша коллекция должна содержать метод `GetEnumerator` возвращающий в свою очередь объект содержащий свойство `Current` и `метод MoveNext()`

**Примечание 1**

> Для того чтобы конструкция `foreach()` успешно компилировалась необходимо, чтобы у объекта был метод `GetEnumerator()`, который вернет объект с методом `MoveNext()` и свойством `Current`. Оператор `foreach` вызывает метод `MoveNext()` до тех пор пока тот не вернёт значение `false`

**Примечание 2**

> Необходимость в сопоставлении с шаблоном (match the pattern) потребовалась разработчикам языка C# 1.0 для того, чтобы реализовать типизированные коллекции без использования обобщений. Интерфейс `IEnumerable` имеет метод `IEnumerator`, который в свою очередь имеет свойства `Current` с типом `object`, а это значит, что было бы невозможно реализовать эффективный итератор, например, по типизированным коллекциям целых чисел, потому что каждый раз при получении элемента выполнялся бы `boxing/unboxing`.

**Идиома .NET для итераторов**

Согласно принятой в .NET идиоме (см. документацию интерфейса `IEnumerable`), итератор должен:

1. **Начальное состояние**:
    - Указывать на элемент перед первым элементом коллекции (то есть, текущий индекс должен быть равен `-1`) после его создания.
    - После первого вызова метода `MoveNext()` итератор должен указывать на первый элемент коллекции.

2. **Метод `MoveNext`**:
    - Должен возвращать `true`, если удалось переместиться на следующий элемент коллекции.
    - Должен возвращать `false`, если коллекция завершена. В этом случае итератор должен указывать на элемент, который идет за последним элементом коллекции.

3. **Метод `Reset`**:
    - Должен возвращать итератор в исходное состояние.

4. **Свойство `Current`**:
    - При попытке обращения к текущему элементу, если итератор указывает на недействительный элемент, должно быть выброшено исключение `InvalidOperationException`.

**Защита от изменений коллекции**

Итератор также должен следить за тем, чтобы коллекция не изменялась после её передачи в конструктор итератора. В случае изменения коллекции и попытки обращения к текущему элементу после изменения коллекции должно быть выброшено исключение `InvalidOperationException`.

**Участники**

   - `IntegerEnumerator`: определяет интерфейс для обхода составных объектов.
   - `IIntegerAggregate`: определяет интерфейс для создания объекта-итератора.
   - `IntegerAggregate.IntegerEnumerator`: конкретная реализация итератора для обхода объекта Aggregate.
   - `IntegerAggregate`: конкретная реализация Aggregate. Хранит элементы, которые надо будет перебирать.
   - `Client`: клиентом в данном случае выступает консольное приложение `Fufelschmerz.Patterns.Iterator.Client`. В классе `Program` создаёт агрегат и выполняется итерация по нему. 



